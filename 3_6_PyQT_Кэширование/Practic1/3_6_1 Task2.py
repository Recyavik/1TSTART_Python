import time
from functools import lru_cache

# Рекурсия — это техника в программировании, при которой функция вызывает саму себя напрямую или косвенно.

# Данные типы функций часто сталкиваются с проблемами скорости, из-за того, что функция постоянно вызывает сама себя.
# Операция рекурсии занимает достаточно много памяти из за постоянного повторения одних и тех же шагов

# Операция рекурсии занимает достаточно много памяти из за постоянного повторения одних и тех же шагов.
# Кэшировнаие или Мемоизация (англ. memoization от англ. memory и англ. optimization)
# помогает этому процессу, сохраняя значения, которые уже были рассчитаны для последующего использования.
# Давайте сначала вспомним что такое рекурсивные функции.

# Она может быть очень полезной для решения определенных задач, но имеет свои ограничения.
# Одно из них — максимальная глубина рекурсии.
#
# В Python предусмотрено ограничение на максимальную глубину рекурсии,
# чтобы предотвратить переполнение стека и последующий сбой программы.
# Это ограничение обычно установлено на достаточно высоком уровне
# (обычно порядка 1000), но иногда, для решения определенных задач,
# может потребоваться увеличить этот лимит.

# Чтобы увеличить максимальную глубину рекурсии, можно использовать
# функцию sys.setrecursionlimit(limit).
# Эта функция устанавливает максимальную глубину рекурсии на указанное значение.
# Но стоит быть осторожным, увеличивая этот лимит, так как это может привести
# к переполнению стека и сбою программы.
import sys
sys.setrecursionlimit(3000)

def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n - 1) + fib(n - 2)
# Как видно на вычисление результата для числа 35, ушло целых 17 секунд.
# По мере того, как растет количество передаваемых данных, растет структура и количество рекурсивных вызовов.
# Он экспоненциальный, что может значительно замедлить работу программы. Даже попытка выполнить fib(40)
# может занять пару минут, а fib(100) обычно не работает из-за проблем с максимальной глубиной рекурсии.
# Что приводит нас к нашей следующей теме о том, как решить эту проблему… кэширование.

# Когда вы заходите на веб-страницу в первый раз, вашему браузеру требуется некоторое время,
# чтобы загрузить изображения и файлы, необходимые странице.
# Когда вы во второй раз зайдете на ту же самую страницу, она обычно загружается намного быстрее.
# Это связано с тем, что ваш браузер использует технику, известную как «кэширование».
# В вычислительной технике мемоизация — это метод оптимизации,
# используемый в первую очередь для ускорения программы,
# сохраняя результаты ранее вызванных функций и возвращая сохраненный результат
# при попытке вычислить ту же последовательность. Это просто известно как кэширование.

# Чтобы применить ее к последовательности Фибоначчи, мы должны понять,
# какой наилучший метод кэширования значений.
# В Python словари дают нам возможность для хранения значений на основе заданного ключа.
# Благодаря скорости и уникальной ключевой структуре словарей мы можем использовать их для хранения значение
# каждой последовательности Фибоначчи. Таким образом, как только одна последовательность,
# такая как fib(3), рассчитывается, его не нужно вычислять снова.
# Он просто сохраняется в кэше и извлекаются по мере необходимости. Давайте попробуем:

cache = {}
def fib_dict(n):
    if n in cache:
        return cache[n]
    result = 0
    if n <= 1:
        result = n
    else:
        result = fib_dict(n - 1 ) + fib_dict(n - 2)
    cache[n] = result
    return result

@lru_cache()
def fib_cache(n):
    if n <= 1:
        return n
    else:
        return fib_cache(n - 1) + fib_cache(n - 2)



print(fib(10))
print(fib_dict(10))
print(fib_cache(10))


print("Тест 5 Рекурсия Фибоначи")
start = time.time()
test5 = fib(35)

print(time.time() - start, "\n")

print("Тест 6 Кэширование словарём Фибоначи")
start = time.time()
test6 = fib_dict(1800)
print(time.time() - start, "\n")


print("Тест 7 Кэш Фибоначи")
start = time.time()
test7 = fib_cache(500)
print(time.time() - start, "\n")



