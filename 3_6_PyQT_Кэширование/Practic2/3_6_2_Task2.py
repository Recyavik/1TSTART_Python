# Стек вызовов, в свою очередь, – это область памяти, в которой выполняются функции.
# При каждом вызове функции создается фрейм – фрагмент памяти, – в котором содержится:
# информация о текущем состоянии выполнения функции;
# значения всех переменных, которые функция получила для обработки;
# локальные данные, созданные во время очередного вызова;
# сведения о строке программы, к которой нужно вернуться после выполнения функции.
# Фреймы помещаются в стек вызовов, как уже было показано в примере выше, и удаляются точно так же, сверху вниз.
# Рекурсивные функции при каждом новом вызове используют данные, созданные во время работы предыдущего вызова.
# Программисту не нужно беспокоиться о работе стека вызовов –
# созданием фреймов и управлением стеком занимается интерпретатор.
# Однако понимание принципа работы стека вызовов значительно упрощает создание рекурсивных функций.

# Переполнить стек в опытных целях можно с помощью простейшей рекурсивной функции,
# которая бесконечно вызывает сама себя, но не возвращает никаких данных
# и не содержит никакого условия для прекращения своей работы:

# def recursive():
#     recursive()
#
# recursive()

# Интерпретатор Python автоматически отслеживает переполнение стека
# и после 1000 бесплодных вызовов завершает работу подобных функций с ошибкой:

# При желании лимит на глубину рекурсии можно увеличить, но сделать его бесконечным,
# разумеется, нельзя – даже самый внушительный объем оперативной памяти в итоге окажется переполненным:

from sys import getrecursionlimit
from sys import setrecursionlimit

print(getrecursionlimit()) # выводит лимит по умолчанию
setrecursionlimit(2000) # увеличивает лимит до 2000 вызовов
print(getrecursionlimit())# выводит новый лимит

# Чтобы стек вызовов не переполнялся, в каждой рекурсивной функции всегда должны быть предусмотрены два случая:
# Граничный, при котором функция завершает работу и возвращает данные в основную программу.
# Рекурсивный, при котором функция продолжает вызывать себя.
def greetings(st):
    print(st)
    if len(st) == 0:  # Граничный случай
        return
    else:  # Рекурсивный случай
        greetings(st[:-1])


greetings('Hello, world!')

def greetings(st):
    print(st)
    if len(st) > 0:
        greetings(st[:-1])

greetings('Hello world!')