# Центр области
#
# Наконец, вычислим «центр масс» белой области на финальном изображении. Для этого воспользуемся функцией
# cv2.moments(), высчитывающей различные «моменты» изображения (нам потребуются статические моменты)
# Подробнее о том, как они считаются, можно почитать в документации OpenCV.
#
# Коротко: момент m00 – просто сумма значений пикселей; m01 – статический момент относительно оси y,
# m10 – статический момент относительно оси x. Центр масс будет в точке (m10 / m00, m01 / m00) - всё как в физике.

import cv2
import numpy as np

cap = cv2.VideoCapture(1) # Создаём объект захвата видео с камеры
while True: # Бесконечный цикл для обработки каждого кадра видео
    res, img = cap.read() # Считываем кадр из видеопотока
    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # Преобразуем цветовое пространство из RGB в HSV
    color_low1 = (0, 100, 100)  # Обозначим нижний предел цвета для фильтрации (оттенок, насыщенность, яркость)
    color_high1 = (15, 255, 255) # Обозначим верхний предел цвета для фильтрации (оттенок, насыщенность, яркость)

    color_low2 = (165, 100, 100)  # Обозначим нижний предел цвета для другой фильтрации (оттенок, насыщенность, яркость)
    color_high2 = (180, 255, 255) # Обозначим верхний предел цвета для другой фильтрации (оттенок, насыщенность, яркость)

    img_thresh1 = cv2.inRange(img_hsv, color_low1, color_high1) # Применяем первый цветовой фильтр к изображению
    img_thresh2 = cv2.inRange(img_hsv, color_low2, color_high2) # Применяем второй цветовой фильтр к изображению
    img_thresh = cv2.bitwise_or(img_thresh1, img_thresh2) # И объединяем результаты двух фильтраций

    cv2.imshow('img_thresh', img_thresh) # Отображаем результаты цветовой фильтрации
    moments = cv2.moments(img_thresh) # Вычисляем момент изображения
# Вполне возможно, что ничего в наш диапазон не попало.
# В этом случае момент `m00` будет равен нулю, и делить
# на него нельзя. Учтём это в наших расчётах.
    if moments["m00"] !=0.0: # Проверка, что момент не нулевой (изображение не пустое)
    # Для рисования круга вокруг центра масс нам нужны
    # целочисленные координаты, поэтому результат деления
    # приводим к целым:
        cnt_x = int(moments["m10"] /moments["m00"])
        cnt_y = int(moments["m01"] /moments["m00"])
# Рисуем окружность на исходном изображении. Параметры:
# img - исходное изображение,
# (cnt_x, cnt_y) - координаты центра окружности,
# 10 - радиус окружности,
# (0, 255, 0) - цвет круга (B=0, G=255, R=0 - зелёный)
# 3 - толщина линии окружности
        img = cv2.circle(img, (cnt_x, cnt_y), 10, (0, 255, 0), 3)
        # Отображаем исходное изображение с кругом вокруг центра масс
        cv2.imshow('image', img)
    if cv2.waitKey(13) >0: # Ожидаем нажатия клавиши Enter
        break