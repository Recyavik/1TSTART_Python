# Pandas предоставляет две основные структуры данных: Series и DataFrame.
# Series – это одномерная индексированная структура данных
# DataFrame – это двумерная структура данных,  представляющая таблицу с рядами и столбцами.

# Самый простой способ создания DataFrame – использовать словарь или двумерный массив NumPy.
# Доступ к данным в DataFrame можно получить с использованием различных методов. Вот несколько примеров:
# Создание DataFrame из двумерного массива NumPy

import pandas as pd

# Самый простой способ создания DataFrame – использовать словарь или двумерный массив NumPy.
# Доступ к данным в DataFrame можно получить с использованием различных методов. Вот несколько примеров:
# Создание DataFrame из двумерного массива NumPy

import numpy as np

numpy_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
import numpy as np

numpy_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
df1 = pd.DataFrame(numpy_array, columns=["A", "B", "C"])
print(df1)
print(df1.index)
print(df1.columns)

data = {
    "Имя": ["Таня", "Андрей", "Миша"],
    "Возраст": [25, 30, 35],
    "Город": ["Москва", "Иркутск", "Сочи"]
}
df = pd.DataFrame(data)
print(df)
print(df1.index)
print(df["Имя"])  # Выбор столбца по названию
print(df.Возраст)  # Выбор столбца через атрибут
print(df.loc[1])  # Выбор строки по индексу
print(df.loc[1, "Город"])  # Выбор значения по индексу строки и названию столбца
print(df.iloc[0])  # Выбор строки по позиции
print(df.iloc[0, 1])  # Выбор значения по позиции строки и столбца

# Мы можем фильтровать данные в DataFrame, используя условные выражения. Вот пример:
filtered_df = df[df["Возраст"] > 30]
print(filtered_df)


# Мы можем изменять значения в DataFrame и удалять столбцы или строки. Вот несколько примеров:
df["Город"] = "Владивосток"  # Изменение значений в столбце
df.loc[1, "Возраст"] = 31  # Изменение значения по индексу строки и названию столбца
df.drop("Возраст", axis=1, inplace=True)  # Удаление столбца
df.drop(0, inplace=True)  # Удаление строки
print(df)
# В этом примере мы изменяем значения в столбце, изменяем отдельное значение по индексу строки и названию столбца,
# а также удаляем столбец и строку из DataFrame.

# Обнаружение пропущенных данных:

data = {
    "Имя": ["Таня", "Андрей", None, "Миша"],
    "Возраст": [25, None, 30, 35],
    "Город": ["Москва", "Иркутск", "Сочи", None],
}
df = pd.DataFrame(data)
print(
    df.isnull()
)  # Возвращает DataFrame с булевыми значениями, указывающими на пропущенные данные
print(df.isnull().sum())  # Суммирует количество пропущенных данных по столбцам
# Метод .isnull() позволяет обнаружить пропущенные данные в DataFrame.

print("Удаление пустых записей")
df = pd.DataFrame(data)
print(df)
print("-----------------------")
# df.dropna(axis=1, inplace= True)  # Удаляет столбцы с пропущенными данными
df.dropna(how="any", inplace=True)  # Удаляет строки с пропущенными данными
print(df)
# Метод .dropna() позволяет удалить строки или столбцы, содержащие пропущенные данные.


print("Заполнение пустых записей")
data = {
    "Имя": ["Таня", "Андрей", None, "Миша"],
    "Возраст": [25, None, 30, 35],
    "Город": ["Москва", "Иркутск", "Сочи", None],
}
df = pd.DataFrame(data)
df["Возраст"].fillna(
    df["Возраст"].mean(), inplace=True
)  # Заполняет пропущенные данные средним значением столбца
df.fillna("Неизвестно", inplace=True)  # Заполняет пропущенные данные заданным значением
print(df)
# Метод .fillna() позволяет заполнить пропущенные данные заданным значением.

# Группировка данных:
import pandas as pd

data = {
    "Город": ["Москва", "Москва", "Санкт-Петербург", "Санкт-Петербург", "Москва"],
    "Год": [2018, 2019, 2018, 2019, 2019],
    "Продажи": [100, 150, 200, 120, 180],
}
df = pd.DataFrame(data)
grouped = df.groupby("Город")  # Группировка по столбцу 'Город'
print(grouped.groups)  # Вывод групп и их индексов
# Метод .groupby() позволяет сгруппировать данные по определенному столбцу или нескольким столбцам.
# Он возвращает объект GroupBy, который содержит информацию о группах и их индексах.

# Применение агрегатных функций:
# Мы можем применять различные агрегатные функции, такие как sum(), mean(), max(), min(), count(), describe(),
# к объекту GroupBy.

# Комбинированная группировка и агрегирование:
print(grouped.sum())  # Сумма значений для каждой группы
print(grouped.mean())  # Среднее значение для каждой группы
print(grouped.max())  # Максимальное значение для каждой группы
print(grouped.min())  # Минимальное значение для каждой группы
print(grouped.count())  # Количество элементов в каждой группе
print(grouped.describe())  # Основные статистические показатели для каждой группы

grouped = df.groupby(["Город", "Год"])  # Группировка по нескольким столбцам
print(grouped.sum())  # Сумма значений для каждой комбинации 'Город' и 'Год'
# Мы можем также группировать данные по нескольким столбцам, указав список столбцов в методе groupby().

print("Соединение матриц")
data1 = {"Имя": ["Таня", "Андрей", "Миша"], "Возраст": [25, 30, 35]}
data2 = {"Имя": ["Таня", "Андрей", "Миша"], "Город": ["Москва", "Иркутск", "Сочи"]}
df1 = pd.DataFrame(data1)
df2 = pd.DataFrame(data2)
print(df1)
print(df2)
print("-----------Соединение матриц---------")
merged = pd.merge(df1, df2, on="Имя")  # Соединение по общему столбцу 'Имя'
print(merged)
# Метод .merge() позволяет соединить два DataFrame по указанному столбцу или нескольким столбцам.

print("Объединение по строкам")
data1 = {"Имя": ["Таня", "Андрей", "Миша"], "Возраст": [25, 30, 35]}
data2 = {"Имя": ["Глеб", "Саша", "Коля"], "Возраст": [28, 32, 37]}
df1 = pd.DataFrame(data1)
df2 = pd.DataFrame(data2)
print(df1)
print(df2)
print("----------Объединение по строкам----------")
concatenated = pd.concat([df1, df2])  # Объединение по строкам
print(concatenated)
# Метод .concat() позволяет объединить несколько DataFrame по строкам.
# В данном примере мы объединяем df1 и df2 в один DataFrame, где данные просто присоединяются друг за другом.

# Объединение по индексу (Join):
print("Объединение по индексам")
import pandas as pd

data1 = {"Возраст": [25, 30, 35]}
data2 = {"Зарплата": [50000, 60000, 70000]}
print(df1)
print(df2)
df1 = pd.DataFrame(data1, index=["Таня", "Андрей", "Миша"])
df2 = pd.DataFrame(data2, index=["Таня", "Андрей", "Миша"])
print("--------------Объединение по индексам------------")
joined = df1.join(df2)  # Объединение по индексу
print(joined)
# Метод .join() позволяет объединить два DataFrame по индексу.


print("Объединение по условию")
data1 = {"Имя": ["Таня", "Андрей", "Миша"], "Город": ["Москва", "Иркутск", "Сочи"]}
data2 = {"Имя": ["Таня", "Андрей", "Коля"], "Возраст": [25, 30, 35]}
df1 = pd.DataFrame(data1)
df2 = pd.DataFrame(data2)
print(df1)
print(df2)
print("---------------Объединение по условию---------")
merged_inner = pd.merge(df1, df2, on="Имя", how="inner")  # Внутреннее объединение
merged_outer = pd.merge(df1, df2, on="Имя", how="outer")  # Внешнее объединение
merged_left = pd.merge(df1, df2, on="Имя", how="left")  # Левое объединение
merged_right = pd.merge(df1, df2, on="Имя", how="right")  # Правое объединение
print("---------------Объединение внутреннее---------")
print(merged_inner)
print("---------------Объединение внешнее---------")
print(merged_outer)
print("---------------Объединение левое---------")
print(merged_left)
print("---------------Объединение правое---------")
print(merged_right)
# Метод .merge() позволяет указать параметр how, который определяет тип объединения:

# pandas - это пакет Python, который предоставляет быстрые, гибкие и выразительные структуры данных,
# предназначенные для того, чтобы сделать работу с "реляционными" или "помеченными" данными простой
# и интуитивно понятной. Он призван стать фундаментальным высокоуровневым строительным блоком
# для практического анализа данных в реальном мире на Python. Кроме того,
# у него есть более широкая цель - стать самым мощным и гибким инструментом анализа
# / манипулирования данными с открытым исходным кодом, доступным на любом языке.
# Он уже успешно продвигается к этой цели.
