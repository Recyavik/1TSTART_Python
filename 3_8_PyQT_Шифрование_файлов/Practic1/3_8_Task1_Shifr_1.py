# Каждый человек, который пользуется компьютером или смартфоном,
# ежедневно сталкивается с криптографией: начиная от работы в интернете по протоколу HTTPS
# и заканчивая печально известными вирусами-шифровальщиками.
# Однако далеко не все понимают, как работает криптография.
# Давайте попробуем в этом разобраться на конкретных примерах.

# Криптогра́фия — # наука о методах обеспечения конфиденциальности
# (невозможности прочтения информации посторонним)

# Одним из разделов криптографии является наука о шифровании.
# В процессе шифрования происходит обратимое изменение информации
# с помощью некоего секрета, что делает информацию недоступной для тех,
# кто секретом не владеет.

# Предположим, что сторона А хочет передать стороне Б секретную информацию. Стоп.
# Именно поэтому в криптографии принято называть стороны обмена информацией
# именами Алиса (Alice) и Боб (Bob).

# Итак, как Алиса может передать сообщение, чтобы никто, кроме Боба,
# не смог прочесть его? Необходимо как-то изменить эти данные
# по заранее согласованному с Бобом алгоритму.
# Простейшим способом реализации такой задачи является подстановочный шифр —
# алгоритм, при котором каждая буква сообщения заменяется на другую букву.
# Например, вместо первой буквы алфавита («А») Боб c Алисой будут использовать третью («В»),
# вместо второй («Б») — четвертую («Г») и так далее.


ALPHA = u'абвгдеёжзийклмнопрстуфхцчшщьъэюя'
# В этом случае алгоритмом шифрования является сдвиг букв алфавита,
# а ключом — цифра 2 (сдвиг на две позиции).
# Любой, кто знает алгоритм и ключ, сможет расшифровать сообщение Алисы.
# Кстати, попробуйте и вы расшифровать это сообщение — стретвоокуф.


def encode(from_file_name, to_file_name, step):
    with open(from_file_name, "r", encoding='utf-8') as file_from:
        data = str(file_from.read())
    with open(to_file_name, "w", encoding='utf-8') as file_to:
        new_text = data.translate(str.maketrans(ALPHA, ALPHA[step:] + ALPHA[:step]))
        file_to.write(new_text)
        return new_text
# Метод str.translate() возвращает копию строки, в которой каждый символ был сопоставлен
# и преобразован согласно карте перевода символов.
# translate() - это встроенный метод в Python,
# который используется для замены определенных символов в строке другими символами
# или их полного удаления. Для метода translate() требуется таблица перевода,
# которая сопоставляет заменяемые символы с их заменителями.
# Эта таблица может быть сгенерирована с помощью метода maketrans(),
# который принимает два аргумента: символы, подлежащие замене, и их замены

def decode(from_file_name, to_file_name, step):
    with open(from_file_name, "r", encoding='utf-8') as file_from:
        data = str(file_from.read())
    with open(to_file_name, "w", encoding='utf-8') as file_to:
        new_text = data.translate(str.maketrans(ALPHA[step:] + ALPHA[:step], ALPHA))
        file_to.write(new_text)
    return new_text

print(decode("test2.txt", "decode.txt", 2))
print(encode("test.txt", "encode.txt", 2))
print(decode("encode.txt", "decode2.txt", 2))
# Такие алгоритмы шифрования, при которых Алиса и Боб должны заранее придумать
# и согласовать одинаковый секрет, называются симметричными,
# а рассмотренный пример является самым простым алгоритмом
# этой группы и называется шифром Цезаря.
# Он считается небезопасным, и его не рекомендуется использовать.
# Наиболее популярными и достаточно криптостойкими
# симметричными алгоритмами являются 3DES и AES.

import string

z = string.ascii_lowercase
print(z)
z2 = string.ascii_uppercase
print(z2)
full = string.ascii_letters
print(full)
digit = string.digits
print(digit)
p = string.punctuation
print(p)

# В ASCII (стандартной системе кодирования символов),
# буквы английского алфавита имеют коды от 97 до 122 для строчных букв
# и от 65 до 90 для прописных. Зная это, можно легко сгенерировать список букв алфавита следующим образом:
english_alphabet = ''.join(chr(i) for i in range(97, 123))
print(english_alphabet)

russian_alphabet = ''.join(chr(i) for i in range(1072, 1104))
print(russian_alphabet)

import secrets
password = secrets.token_urlsafe(32)

print(password)

# Но что же делать, если Алиса и Боб находятся далеко друг от друга
# и не могут договориться об использовании одинакового секрета,
# поскольку есть некая Ева (от англ. eavesdropper — подслушивающий),
# которая так и хочет узнать тайны Алисы и Боба?
# В этом случае Боб может отправить Алисе замок,
# ключ от которого есть только у него.
# Алиса положит письмо в коробку и запрёт её на этот замок.
# Теперь ни Алиса, ни Ева не смогут открыть коробку и прочесть письмо.
# Аналогичный подход используется в асиметричном шифровании,
# которое также называют криптосистемой с открытым ключом.
# В примере с Алисой и Бобом секретным ключом Боба будет ключ от замка,
# а публичным ключом условно можно назвать сам замок.
# Отправка Алисе замка — это алгоритм согласования ключей.
# Наиболее популярным алгоритмом шифрования с открытым ключом является RSA.
# Вот как выглядит его реализация на языке Python с использованием библиотеки RSA:

# pip install rsa
import rsa

#Боб формирует публичный и секретный ключ

(bob_pub, bob_priv) = rsa.newkeys(512)

#Алиса формирует сообщение Бобу и кодирует его в UTF8,
#поскольку RSA работает только с байтами
message = 'hello Bob!'.encode('utf8')

#Алиса шифрует сообщение публичным ключом Боба
crypto = rsa.encrypt(message, bob_pub)

#Боб расшифровывает сообщение своим секретным ключом
message = rsa.decrypt(crypto, bob_priv)
print(message.decode('utf8'))