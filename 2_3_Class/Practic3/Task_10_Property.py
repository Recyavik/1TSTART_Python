# Сегодня я хочу чтобы вы узнали о более удобном способе работы
# с приватными атрибутами через специальный объект property

class Rectangle:
    def __init__(self, width, height):
        self.__width = width
        self.__height = height

# Основной использования методов получения и установки является обеспечение инкапсуляции данных
# в объектно-ориентированных программах. В отличие от других объектно-ориентированных языков,
# частные переменные в Python не являются скрытыми полями.
# Некоторые языки ООП используют методы получения и установки для инкапсуляции данных.
# Мы хотим скрыть атрибуты класса объекта от других классов,
# чтобы методы других классов случайно не изменили данные.

# Для этого надо использовать декоратор @property

# В двух словах, декоратор – это функция, которая расширяет функционал другой функции.
# Основная цель любого декоратора – изменить методы или атрибуты класса,
# чтобы пользователю класса не нужно было изменять свой код.

# Чтобы использовать декоратор свойств, нам нужно обернуть его вокруг любой функции или метода.

    @property
    def width(self):
        return self.__width
# По умолчанию использование @property делает это свойство доступным только для чтения.
# А как же изменить это свойство. Как перезаписать приватную ширину,
    # да еще и проверить её перед записью на валидность?
    @width.setter
    def width(self, w):
        if w > 0:
            self.__width = w
        else:
            raise ValueError

    @width.deleter
    def width(self):
        del self.__width

    @property
    def height(self):
        return self.__height

    @height.setter
    def height(self, h):
        if h > 0:
            self.__height = h
        else:
            raise ValueError

    def area(self):
        return self.__width * self.__height

rect = Rectangle(10, 20)
# del rect.width
print(rect.width)

rect.width = 50
print(rect.width)


Rectangle.width = 5
print(Rectangle.width)

# Это очень удобно, потому что через один атрибут мы можем и считывать данные из приватного атрибута
# или записывать в него

# Именно поэтому свойства широко используются в современных проектах с открытым исходным кодом.
# Они упрощают задачу для конечного пользователя, а также позволяют разработчикам легко отделить
# скрытые атрибуты от не скрытых свойств.

# Это позволяет избежать функциональное дублирование атрибутов get и set
